/*** <<< Коды состояния >>> ***/
{  // 2xx
	200  // => ок
}
{  // 3xx
	301  // => ресурс перемещен навсегда (кеширует перенаправление, поэтому иногда игнор. обр. формы)
	302  // => ресурс временно перемещен (не кеширует перенаправление)
	303  // => смотрите другой ресурс (не кеширует перенаправление)
}
{  // 4xx
	404  // => не найдено
}
{  // 5xx
	500  // => ошибка сервера
}



/*** <<< Адресная строка >>> ***/
// Важно понимать, что мы можем интерпретировать строку запроса (и не только)
// по своему, не обязательно там должен быть именно знак '?'

// https://www.google.com/#q=express
// http:// - протокол
// www.google.com - имя хоста
// / - путь
// '' - пустая строка запроса (тут ее нет)
// #q=express - фрагмент

// http://localhost:8080/about?test=1#history
// http:// - протокол
// localhost - имя хоста
// 8080 - номер порта
// /about - путь
// ?test=1 - строка запроса
// #history - фрагмент



/*** <<< RESTfull API >>> ***/

// 1 вариант:
//
// PUT - для обновления
// POST - для добавления
// GET - для получени
// DELET - для удаления

// 2 вариант:
//
// Всегда использовать POST со ссылками вида:
// /products/add
// /products/destroy
// /products/get



/*** <<< Форматы, заголовки, кодировки, стандарты >>> ***/

// Ответа:
//
'Content-Type': 'text/html' || 'text/plain' || 'application/json' || 'application/xml' || 'text/xml'
'Content-Disposition': 'attachment'
'Set-Cookie': 'max-age=3600; secure=true';  // Пример заголовка для отправки Cookie
{  // Контроль над кэшированием
	// Важно!!! Если мы используем кэширование в 1 год, топ при обновлении
	// ресурса пользователь не увидит этих обновлений целый год. Чтобы исправить данную
	// проблему нужно использовать "сигнатуры"!
	// Можно устанавливать эти заголовки вручную, во многих
	// крупных CDN эти заголовки по-умолчанию работают "хорошо".
	// Тут как-то фигурирует Nginx?

	'Expires' / 'Cache-Control'
	'Last-Modified' / 'ETag'
}

// Запроса:
//
// Формат данных для тела запроса POST и GET
application/x-www-form-urlencoded  // закодированные пары 'имя'='значение'&'имя'='значение' (такой же как в обычном GET)
multipart/form-data  // если требуется поддержка загрузки файлов на сервер
application/json  // для AJAX



/*** <<< Cookies, Sessions >>> ***/
// Требуется поддержка промежуточного ПО cookie-parser

// Объекты содержащие значения куки-файлов, передаваемые от клиента.
req.cookies / req.signedCookies

// Устанавливает атрибуты (options) в куки-файл с именем name
res.cookie(name, value, [options])

// Очещает куки-файл
res.clearCookie(name, [options])

{  // options
	// в качестве параметров для куки файлов может быть переданы следующие атрибуты

	domain
	path
	maxAge
	httpOnly  // куки-файл может менять только сервер
	secure  // только через https
	signed  // подписать куки-файл?
}



/*** <<< Объект запроса request >>> ***/
// Лежит в http.IncomingMessage

// Ссылка на текущий экземпляр приложения
req.app

// Массив, содержащий именованные параметры маршрутизации
req.params

// Возвращает именованный параметр маршрутизации или параметры GET/POST.
// Рекомундуется избегать использованиеэ того метода.
req.param(name)

// Объект, содержащий параметры строки запроса (иногда называемые GET-параметрами)
// в виде пар "имя/значение".
req.query

// Объект, содержащий параметры POST.
// Нужно промежуточное ПО, которое позволит сделать синтаксический разбор содержимого тела.
// Например плагин body-parser.
req.body

// Информация о текущем совпавшем маршруте. Полезна, главным образом для отлкдки маршрутизации.
req.route

// Значения сеансовых переменных. Например как только мы настроили express-session модуль
// req.session выполняет и чтение и задание значения, т.к. у объекта ответа нет свойства session
req.session

// Объекты содержащие значения куки-файлов, передаваемые от лкиента.
req.cookies / req.signedCookies

// Заголовки запроса, полученные от клиента
req.headers

// Удобный метод для принятия решения о том, должен ли клиент принимать
// данный тип или типа (необязательный параметр types может быть одиночным
// типом MIME, например application/json, Разделенным зазпятыми
// списком или массивом). Этот метод обычно интересен тем, кто пишет публичные API;
// он предполагает, что браузеры всегда по умолчанию принимает HTML.
req.accepts([types])

// IP-адрес клиента
req.ip

// Путь запроса (без протокола, хоста, порта или строки запроса)
req.path

// Удобный метод, возвращающий переданное клиентом имя хоста. Эта информация
// может быть подделана и не должна использоваться из соображений безопасности.
req.host

// Удобное свойство, возвращающее true, если запрос порожден вызовом AJAX
req.xhr

// Протокол, использованный при совершении данного запроса. (напр http или https)
req.prototcol

// Удобное свойство, возвращающее true, если соединение является безопасным.
// Эквивалентно req.prototcol === 'https'
req.secure

// Небольшая неточность в наименовании - эти свойства возвращают путь и строку
// запроса (напр, '/about?foo=bar'). req.url может быть изменен для нужд внутренней маршрутизации, но req.originalUrl
// разработан так, чтобы всегда хранить исходный путь и строку запроса.
req.url/req.originalUrl/req.baseUrl/req.path

// Удобный метод, возвращающий массив (естественных) языков, которые предпочтительны клиенту.
// Эта информация получается путем анализа заголовка запроса.
req.acceptedLenguages



/*** <<< Объект ответа response >>> ***/
// Лежит в http.ServerResponse

// Ссылка на текущий экземпляр приложения
res.app

// Устанавливает код состояния HTTP. По умолчанию в Express код состояния - 200 ('ОК').
// Это значит, что его нужно использовать практически только для 404 и 500 кодов. Так как
// для перенаправлений лучше использовать метод res.redirect();
res.status(code)

// Устанавливает заголовок ответа. Врят ли в обычных условиях это будет делатся вручную.
res.set(name, value)

// Устанавливает или очещает куки-файлы, которые будут храниться на клиенте.
// Требуется поддержка промежуточного ПО cookie-parser
res.cookie(name, value, [options]) / res.clearCookie(name, [options])

// Выполняет перенаправление браузера. Код перенаправления по умолчанию - 302 (найдено).
// В целом лучше минимизировать перенаправления, за исключением случая
// окончательного перемещения страницы, когда следует использовать код 301.
res.redirect([status], url)

// Отправляет ответ клиенту с необазательным кодом состояния. По умолчанию в
// Express используется тип содержимого text/html, так что, если мы захотим
// изменить его на text/plain, например, необходимо вызвать res.set('Content-Type': 'text/plain')
// перед вызовом res.send(). Если тело - объект или массив, вместо этого ответ будет отправлен в виде
// JSON (с установленным соответствующим типом содержимого), хотя, хотя, если мы захотим отправить JSON,
// лучше делать это явным образом путем вызова res.json()
res.send(body) / res.send(status, body)

// Отправляет JSON клиенту с необязательным кодом состояния
res.json(json) / res.json(status, json)

// Отправляет JSONP клиенту с необязательным кодом состояния
res.jsonp(json) / res.jsonp(status, json)

// Удобный метод для установки заголовка Content-Type. Практически эквивалентен
// res.set('Content-Type': type). Оно немного более умное, т.к. может правильно
// поставить тип данных интернета по расширению файла, например: res.type('txt')
// Результатом будет 'Content-Type': 'text/plain', но лучше данной возможности
// избегать, и ставить тип данных интернета явным образом.
res.type(type)

// Этот метод позволяет отправлять разнообразное содержимое в зависимости от заголовка
// Accept запроса. Он в основном используется в различных API, и оно обсуждается подробнее
// в главе 15. Вот очень простой пример: res.format({'taxt/plain': 'Hello!, 'text/html': <b>Hello!</b>});
res.format(object)

// Оба этих мемтода устанавливают заголовок ответа Content-Disposition в значение attachment;
// это указывает браузеру загружать содержимое вместо отображения его в браузере. Можно задать
// filename в качестве подсказки браузеру. С помощью
// res.download() можно задать файл для скачивания, в то время как
// res.attachment() просто устанавливает заголовок и вам все еще нужно будет отправить контент клиенту.
res.attachment([filename]) / res.download(path, [filename], [callback])

// Этот метод читает файл, заданный параметром path, и отправляет его содержимое клиенту.
// Этот метод редко оказывается нужен - проще использовать промежуточное ПО static
// и разместить файлы, которые мы хотитм сделать доступными клиенту, в каталоге public.
// Оданко, если мы хотмм выдать другой ресурс с того же URL в зависимости от какого-либо
// условия, этот метод может оказаться полезен.
res.sendFile(path, [options], [callback])

// Задает заголовок ответа Links. Это узкоспециализированный заголовок, редкоиспользуемый
// в большинстве приложений.
res.links

// res.locals - объект, содержащий контекст ПО УМОЛЧАНИЮ для визуализации представлений.
// res.render - визуализирует представление, используя указанный в настройках шаблонизатор
// (не путать параметр locals в res.render с res.locals он перекрывает контекст в res.locals,
// но не перекрытый контекст по-прежнему будет доступен). Обратите внимание на то, что res.render
// по умолчанию будет приводить к коду состояния ответа 200; используйте res.status для указания
// других кодов состояния. Визуализация представлений - отдельная, не маленькая тема.
res.locals / res.render(view, [locals], callback)
