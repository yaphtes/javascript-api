// В отличие от объектов, в которых ключами могут быть только строки,
// в коллекциях ключом может быть произвольное значение, даже объект.


{  // Map
    // Map – коллекция для хранения записей вида ключ:значение.


    let map = new Map(iterable?: [?]);

    // установить значение в map,
    // данный метод можно чейнить
    map.set(key: ?, value: ?)

    // прочитать значение из map
    map.get(key: ?)  // => ?

    // количество записей в map
    map.size  // => number

    // проверяет наличие записи
    map.has(key: ?)  // => boolean

    // удаляет запись
    map.delete(key: ?)  // => boolean

    // очищает map
    map.clear()

    {  // итерация

        // возвращает итерируемый объект для ключей
        map.keys()

        // возвращает итерируемый объект для значений
        map.values()

        // возвращает итерируемый объект для записей [ключ, значение], он используется по-умолчанию в for..of
        map.entries()

        // Выполняет переданную функцию единожды для каждой пары ключ/значение объекта Map в порядке их вставки.
        map.forEach(callback: fn(value: ?, key: ?, map: Map), thisArg?: ?)
    }
}


{  // Set
    // Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.


    let set = new Set(iterable?: [?])

    // добавляет значение в коллекцию,
    // метод можно чейнить
    set.add(value: ?)

    // удаляет значение из коллекций
    set.delete(value: ?)  // => boolean

    // проверяет наличие значения
    set.has(value: ?)  // => boolean

    // очищает set
    set.clear()

    { // итерация

        // Выполняет переданную функцию единожды для каждого значения объекта Set в порядке их вставки.
        // value1 и value2 совпадают - это сделано для совместимости с Map
        set.forEach(callback: fn(value: ?, value2: ?, set: Set), thisArg?: ?)
    }
}


{  // WeakMap и WeakSet
    // WeakSet – особый вид Set не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.
    // То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти.

    // Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится
    // где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.


    let weakpam = new WeakMap(iterable?: [?]);
    let weakset = new WeakSet(iterable?: [?]);

    {  // weakmap

        // добавляет новую запись
        weakpam.set(key: ?, value: ?)

        // удаляет запись
        weakpam.delete(key: ?)

        // читает запись
        weakpam.get(key: ?)

        // проверяет наличие записи
        weakpam.has(key: ?)
    }

    {  // weakset

        // добавляет запись
        weakset.add(value: ?)

        // проверяет наличие записи
        weakset.has(value: ?)

        // удаляет запись
        weakset.delete(value: ?)
    }

}


// ИТОГО:
// Map – коллекция записей вида ключ: значение, лучше Object тем, что перебирает всегда в порядке вставки и допускает любые ключи.
// Set – коллекция уникальных элементов, также допускает любые ключи.

// Основная область применения Map – ситуации, когда строковых ключей не хватает (нужно хранить соответствия для ключей-объектов),
// либо когда строковый ключ может быть совершенно произвольным.

// К примеру, в обычном объекте Object нельзя использовать «совершенно любые» ключи. Есть встроенные методы, и уж точно
// есть свойство с названием __proto__, которое зарезервировано системой. Если название ключа даётся посетителем сайта,
// то он может попытаться использовать такое свойство, заменить прототип, а это, при запуске JavaScript на сервере, уже
// может привести к серьёзным ошибкам.

// WeakMap и WeakSet – «урезанные» по функционалу варианты Map/Set, которые позволяют только «точечно» обращаться элементам
// (по конкретному ключу или значению). Они не препятствуют сборке мусора, то есть если ссылка на объект осталась только в
// WeakSet/WeakMap – он будет удалён.
