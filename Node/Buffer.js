// В Node лучше использовать Buffer, а не ArrayBuffer, как на клиенте.
// Содержимое Buffer в Node копируется, вместо ссылки на тот же участок
// памяти, как это сделано в ArrayBuffer в клиентском JS

// Возвращает буфер с копией содержимого
Buffer.from()

// Создает заполненный буфер определенного размера
Buffer.alloc(size, fill?, encoding?)

// Создает буфер определенного размера, который может содержать старые или
// конфиденциальные данные и в дальнейшем должен быть заполнен вызовом Buffer.prototype.fill()
// Создается с некими артефактами данных (для чего?)
Buffer.allocUnsafe()

// Сравнивает buf1 и buf2, как правило, для сортировки массивов экземпляров Buffer. Это эквивалентно вызову buf1.compare(buf2)
Buffer.compare(buf1, buf2)



// Заполнить буфер
Buffer.prototype.fill(value, offset?, end?, encoding?)

// Преобразовать буфер в строку, по-умолчанию в utf-8, если мы получаем буфер в потоке, то вместо
// этого метода необходимо воспользоваться классом StringDecoder
Buffer.prototype.toString(encoding ?, offset ?, end ?)

// Записывает строку с заданной кодировкой (по-умолчанию utf-8) в буфер, нужно слидить, чтобы хватало длины буфера
Buffer.prototype.write(string, offset ?, length ?, encoding ?)

// Создает срез данных и возвращает его. К сожалению данные изменяются на месте, нужно это учитывать.
Buffer.prototype.slice(offset ?, end ?)

// Скопировать байты из одного буфера в другой. В targetBuffer должно хватать пространства, иначе будет скопирована только часть.
Buffer.prototype.copy(targetBuffer, targetStart?, sourceStart, sourceEnd)

// Сравнение байтов. Возвращает прнизнак относительного расположения сравниваемых буферов в лексикографическом порядке.
// Если сравниваемый буфер предшествует другому, то возвращает -1, если нет, то 1. Если два буфера содержат одинаковые байты - возвращает 0.
Buffer.prototype.compare(otherBuffer, targetStart?, targetEnd?, sourceStart?, sourceEnd?)


// Размур буфера
Buffer.prototype.length
