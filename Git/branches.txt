Ветки позволяют деверсифицировать разработку
Технически ветки в гит - это ссылки на коммиты. Они ссылаются на вершину коммитов ответвления.

<name> - имя ветки
<commit> - ветка, которая указывает на коммит, либо идентификатор любого коммита, либо тэг
<paths> - файл/файлы/деррикторию
-- <paths> - двойной дифис помогает понять git, что указан именно путь, а не ветка.
Например: git checkout -- master - возвращает состояние из индекса в рабочую деррикторию ФАЙЛА или ДЕРРИКТОРИИ master

##### Ветки #####

git branch - посмотреть ветки проекта
git branch -v - посмотреть ветки проекта и показать вершину ветки
git branch <name> - создать ветку <name>
git branch <name> <commit> - создать ветку, которая указывает на коммит (например, для скорого восстановления недостижимых коммитов, или восстановления случайного удаления ветки)
git branch -f <branch> <commit> - сбросить (вернуть ветку, переместить) в состояние <commit>
git branch -d <branch> - удалить ветку, перед этим необходимо слияние
git branch -D <branch> - полностью удалить ветку, без слияния

git checkout <name> - переключить ветку (переместить HEAD на ветку <name>)
git checkout -b <name> - создать ветку и переключиться на нее
git checkout -f <branch> - переключить на другую ветку и уничтожить изменения в текущей
git checkout -f HEAD - удалить все незакоммиченные изменения в текущей ветки
git checkout <paths> - вовзвращает состояние рабочей дерриктории из индекса в рабочую деррикторию
git checkout <commit> <paths> - восстанавливает данные (файлы и их состояние) из <commit> в рабочую деррикторию (это может быть один файл, а может и целая дерриктория) и в индекс
!!!
PS: checkout, при переключении, сохраняет изменения файла, если эти файлы в разных ветках одинаковы
и помечает файлы флагом M в выводе в консоль, при переключении ветки. Внимательно следим за этим
флагом, чтобы случайно не применить изменения из одной ветки к другой.
С другой стороны, такое поведение checkout МОЖНО И ДАЖЕ НУЖНО НУЖНО использовать для вынесения
больших незакоммиченных изменений в отдельную ветку. - такое случается, когда изначально
предполагался небольшой фикс или фича, но в итоге она оказывается огромной и времени на ее
реализацию не хватает. Тогда выделяем незакоммиченные изменения в отдельную ветку и реализовываем позже.
!!!

git stash - убрать все незакоммиченные изменения и поместить их в специальную архивированную структуру данных git
git stash pop - добавить изменения из git stash

git cherry-pick <commits> - скопировать коммиты на текущую ветку


##### История #####
git log - просмотр полной истории коммитов
git log <branch> - просмотр истории коммитов ветки
git log <tag> - просмотр истории коммитов, начиная с тега
--флаги
--oneline - в одну строку
--decorate - декорировать (например, отобразить теги и ветки)

git show :/<regexp> || <string> - просмотр коммита в описании которого находится указанное слово
git show <commit> - просмотр коммита
git show <commit>:<file> - просмотр файла на состояние коммита
git show :<file> - просмотр файла в индексе
git show <commit>~ - просмотр коммита предыдущего от <commit>
git show <commit>~~ - просмотр коммита предыдущего от <commit> дважды. И тп по такому принципу.
git show <commit>~<n> - просмотр коммита предыдущего от <commit> <n> коммитов назад.
--флаги
--quiet - только информация коммита, без самих изменений

git reflog <branch> - просмотр рефлога ветки
--флаги
--date=iso - указать дату коммитов (полезно, если мы помним примерную дату коммитов)
--pretty=short - чуть более подробная информация коммитов, например, добавляет авторов коммитов

## Сборка мусора ##
https://www.youtube.com/watch?v=32dlNvz5OEo&list=PLDyvV36pndZHkDRik6kKF6gSb0N0W995h&index=28

