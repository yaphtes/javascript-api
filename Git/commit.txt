git commit <paths> - закоммитить проиндексированные изменения
--флаги
-m - указать message коммита
-a - закомитить изменения с пропуском стадии добавлении в индекс, работает только для проиндексированных файлов
--author="John Smith" --date="..." - указание автора и даты изменений
--amend - переместить текущую ветку и HEAD на один коммит назад, не обновляя рабочую область и индекс и тут же закоммитить текущие изменения
-c <commit> - скопировать message и данные об авторе с <commit> в создаваемый
--reset-author - скопировать только message, без данных об авторе
--no-edit - не открывать редактор
-v - добавляет результат git diff --cached в ознакомительный файл перед коммитом
--fixup=<commit> - сделать коммит-заплатку для коммита (это обычный коммит, с точки зрения истории, но он мержится с целевым, при rebase -i)
--squash=<commit> - то же, что и выше, просто другой тип коммита для rebase -i

##### Обратные коммиты #####
git revert <commits> - создать коммиты, обратные коммитам <commits> (удалить изменения, сделанные в <commits>)
--флаги git revert ...
(-m <n>)* - <n> (1 или 2) используется для обратных коммитов слияния, -m указывает по отношению к какому родителю сделать обратный коммит

* Если мы попытаемся использовать merge в целевой ветке после добавления коммита отмены слияния, то это не сработает, т.к. ветка уже была слита
и git возьмет не все нужные коммиты, а только новые (те, что после слияния). Поэтому перед новым слиянием необходимо сделать обратный коммит коммиту отмены слияния
и только потом потом использовать git merge. Это не очень элегантно (делается два коммита для нового слияния), поэтому, если ситуация позволяет, то
лучше избегать коммитов отмены слияний. Поведение с rebase немного другое. 

Важные выпуски для отмены слияний и повторных rebase:
https://www.youtube.com/watch?v=ktsxDQxcaJ0&list=PLDyvV36pndZHkDRik6kKF6gSb0N0W995h&index=65
https://www.youtube.com/watch?v=YVSB2427tUo&list=PLDyvV36pndZHkDRik6kKF6gSb0N0W995h&index=66
