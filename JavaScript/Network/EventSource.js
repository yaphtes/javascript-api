let eventSource = new EventSource(url, options);
options = {
	withCredentials: true
	// e.t.c.
}; // -> кроссдоменные запросы
// при кроссдоменных запросах, будет свойствое event.origin объекта
// события, которое отображает адрес источника, откуда пришли данные

// Пример:
eventSource.onmessage = function(event) {
	console.log('Пришло сообщение: ' + event.data);
};


{  // события eventSource

	open // При установлении соединения
	message // При сообщении, данные – в event.data
	error // При ошибке, в том числе – закрытии соединения по инициативе сервера.
	readyState // статус соединения {
		0 // в процессе (пере-)соединения
		1 // соединение установлено
		2 // соединение закрыто
	// }

	// p.s.: Если сервер присылает имя события в event:, то такие события нужно обрабатывать через addEventListener.
}

{  // Свойства объекта

	// Текущее состояние соединения, одно из EventSource.CONNECTING (=0),
	// EventSource.OPEN (=1) или EventSource.CLOSED (=2).
	event.readyState

	// Последнее полученное id, если есть. При возобновлении соединения браузер
	// указывает это значение в заголовке Last-Event-ID.
	event.lastEventId

	// Параметры, переданные при создании объекта. Менять их нельзя.
	event.url
	event.withCredentials
	// e.t.c.
}

{  // Методы

	eventSource.close() // закрывает соединение
}


// P.S.:
// При любом закрытии соединения, в том числе если сервер ответит на запрос и закроет соединение сам – браузер через короткое время повторит свой запрос.
// Есть лишь два способа, которыми сервер может «отшить» надоедливый EventSource:
// Ответить со статусом не 200.
// Ответить с Content-Type, не совпадающим с text/event-stream.


// Формат ответа сервера:
// Сервер присылает пустые строки, либо строки, начинающиеся с:
// data: – сообщение, несколько таких строк подряд склеиваются и образуют одно сообщение.
// id: – обновляет lastEventId.
// retry: – указывает паузу между пересоединениями, в миллисекундах. JavaScript не может указать это значение, только сервер.
// event: – имя события, должен быть перед data:.
